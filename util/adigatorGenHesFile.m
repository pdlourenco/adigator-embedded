function output = adigatorGenHesFile(UserFunName,UserFunInputs,varargin)
% ADiGator Hessian File Generation Function: this function is used when you
% wish to generate a Hessian+gradient of a function with an input variable
% of differentiation (and any auxiliary inputs), and a single output. This
% simply calls the function adigator twice and creates a wrapper function
% s.t. the input of the resulting file is the same as the input to the
% original user function, but outputs the Hessian, gradient, and function
% values.
%
% ------------------------------ Usage -----------------------------------
% function adigatorGenHesFile(UserFunName,UserFunInputs)
%                   or
% function adigatorGenHesFile(UserFunName,UserFunInputs,Options)
%
% ------------------------ Input Information -----------------------------
% UserFunName: String name of the user function to be differentiated
%
% UserFunInputs: N x 1 cell array containing the inputs to the UserFun
%                - the input (or cell array element/structure field)
%                corresponding to the variable of differentiation must be
%                created using the adigatorCreateDerivInput function.
%                i.e. if the first input is the variable of
%                differentiation, then the first input must be created
%                using adigatorCreateDerivInput prior to calling adigator.
%                - any other numeric inputs should be defined as they will
%                be when calling the derivative function. These will be
%                assumed to have fixed sizes and zero locations, but the
%                non-zero locations may change values. If the values are
%                always fixed, then adigatorOptions may be used to change
%                the handling of these auxiliary inputs.
%                - auxiliary inputs may also be created using the
%                adigatorCreateAuxInput function.
%
% Options (optional): option structure generated by adigatorOptions
%                     function
%
% ------------------------ Output Information ----------------------------
% The output is a structure of the names of the files that are generated,
% together with the original function name and the Hessian sparsity
% pattern. If the user's function is called 'myfun', then the Hessian file
% will be titled 'myfun_Hes', and the gradient file will be titled
% 'myfun_Grd'. The output structure would then be
%     output.FunctionFile = 'myfun'
%     output.GradientFile = 'myfun_Grd'
%     output.HessianFile  = 'myfun_Hes'
%     output.HessianStructure = sparse ones and zeros.
% The generated Hessian/gradient files have the same input structure as the
% original user function. The output of Hessian file is [Hes, Grd, Fun].
% The output of gradient file is [Grd, Fun].
%
% ----------------------- Additional Information -------------------------
% The Hessian is built as a sparse matrix under the condition that
% numel(Hes) >= 250 & nnz(Hes)/numel(Hes) <= 3/4, otherwise it is built as
% a full matrix.
%
% If y is output, x is input such that numel(y) = m,
% numel(x) = n > 1, then the Hessian will be built such that 
% size(Hes) = [m*n n]. If m > 1, n = 1, then size(Hes) will be [m m].
%
% The functions generated Hessian/gradient files are simply wrapper files
% for the ADiGator generated files (named
% 'myfun_ADiGatorHes'/'myfun_ADiGatorGrd')
%
% Copyright 2011-2014 Matthew J. Weinstein and Anil V. Rao
% Distributed under the GNU General Public License version 3.0
%
% see also adigator, adigatorCreateDerivInput, adigatorCreateAuxInput,
% adigatorOptions, adigatorGenJacFile
%
%   Modifications as described below are Copyright GMV.
%   2025-10  PEDRO LOURENÇO (PADL) - palourenco@gmv.com
%
%   Changelog:
%   2025-10 Pedro Lourenço  v1.5    Store the generated derivative file and
%                                   and the mat file with the static
%                                   derivative data in the user provided
%                                   folder and not necessarily in the 
%                                   calling directory
%                                   Add parser for the user provided options
%                                   Provide the paths to all the generated
%                                   functions and files (.mat and .m)
%                                   Modify output gradients to be in column
%                                   form, i.e. f = df/dx'*x+x'*d2f/dx2*x;
%                                   when computing gradients. Maintaining 
%                                   numerator form when computing Hessians and Jacobians

%% ~~~~~~~~~~~~~~~~~~~~~~~~~~ OPTIONS SETUP ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ %%
opts = adigatorOptions();
if nargin == 2
  opts.overwrite = 1;
else
    optfields = fieldnames(varargin{1});
    for Fcount = 1:length(optfields)
        opts.(lower(optfields{Fcount})) = varargin{1}.(lower(optfields{Fcount}));
    end
    if ~isfield(varargin{1},'overwrite')
        opts.overwrite = 1;
    end
end

%% ~~~~~~~~~~~~~~~~~~~~~~~~~~ INPUTS PARSING ~~~~~~~~~~~~~~~~~~~~~~~~~~~ %%
if ~ischar(UserFunName)
  error(['First input to adigator must be string name of function to be ',...
    'differentiated']);
end
NameAppendix   = 'Grd';
GrdFileName    = [UserFunName,'_Grd'];          % Name of gradient wrapper
AdiGrdFileName = [UserFunName,'_ADiGatorGrd'];  % Name of first deriv file
HesFileName    = [UserFunName,'_Hes'];          % Name of hessian wrapper
AdiHesFileName = [UserFunName,'_ADiGatorHes'];  % Name of second deriv file

% Quick input check
if ~iscell(UserFunInputs)
  error(['Second input to adigator must be cell array of inputs to ',...
    'the function described by first input string']);
end
derflag = 0;
for I = 1:numel(UserFunInputs)
  x = UserFunInputs{I};
  if isa(x,'adigatorInput')
    if ~isempty(x.deriv)
      if derflag > 0
        error('adigatorGenHesFile is only used for single derivative variable input')
      end
      derflag = I;
    end
    if any(isinf(x.func.size))
      error('adigatorGenHesFile not written for vectorized functions')
    end
  end
end
if derflag == 0
  error('derivative input of user function not found - possibly embedded within a cell/structure, use adigator function if this is the case');
end

% File checks
if isempty(opts.path) % v1.5 - allow user to specify the path
    CallingDir = cd;
else
    CallingDir = opts.path;
    if ~exist(CallingDir,'dir') % directory does not exist -> create it
        mkdir(CallingDir);
    end
end
% v1.5 - add chosen directory to the path to allow storage
% in userdefined directories
original_path = path();
addpath(CallingDir);

UserFun = str2func(UserFunName);
% Output Check
if nargout(UserFun) ~= 1
  error_restore_path(original_path,'User function must contain single output');
end

% Store the path to the generated files (v1.5)
ADiGator_GeneratedFiles.Grd = fullfile(CallingDir, [GrdFileName, '.m']);
ADiGator_GeneratedFiles.Hes = fullfile(CallingDir, [HesFileName, '.m']);

if exist(ADiGator_GeneratedFiles.Grd,'file')
  if opts.overwrite
    delete(ADiGator_GeneratedFiles.Grd);
    rehash
  else
    error_restore_path(original_path,['The file ',ADiGator_GeneratedFiles.Grd,' already exists, ',...
      'quitting transformation. To set manual overwrite of file use ',...
      '''''adigatorOptions(''OVERWRITE'',1);''''. Alternatively, delete the ',...
      'existing file and any associated .mat file.']);
  end
end
if exist(ADiGator_GeneratedFiles.Hes,'file')
  if opts.overwrite
    delete(ADiGator_GeneratedFiles.Hes);
    rehash
  else
    error_restore_path(original_path,['The file ',ADiGator_GeneratedFiles.Hes,' already exists, ',...
      'quitting transformation. To set manual overwrite of file use ',...
      '''''adigatorOptions(''OVERWRITE'',1);''''. Alternatively, delete the ',...
      'existing file and any associated .mat file.']);
  end
end

% Call adigator twice
try % v1.5 - add try-catch to avoid leaving unnecessary changes to path active
    [adiout,FunctionInfo,ADi_DerivFiles,ADi_DerivFuns] = adigator(UserFunName,UserFunInputs,AdiGrdFileName,opts); % v1.5 - add new output with list of files/functions
catch ME
    path(original_path);
    rethrow(ME);
end
adiout = adiout{1};
% Change derivative input
x = UserFunInputs{derflag};
xsize = x.func.size;
vodname = x.deriv.vodname;
UserFunInputs{derflag} = struct('f',x,['d',vodname],ones(prod(xsize),1));

try % v1.5 - add try-catch to avoid leaving unnecessary changes to path active
[adiout2,FunctionInfo2,ADi_DerivFiles2,ADi_DerivFuns2] = adigator(AdiGrdFileName,UserFunInputs,AdiHesFileName,opts); % v1.5 - add new output with list of files/functions
catch ME
    path(original_path);
    rethrow(ME);
end
adiout2 = adiout2{1};

% v1.5 - restore the path to its original state
path(original_path);

Gfid = fopen(ADiGator_GeneratedFiles.Grd,'w+');
Hfid = fopen(ADiGator_GeneratedFiles.Hes,'w+');

InputStrs = FunctionInfo.Input.Names.';
xstr = InputStrs{derflag};
for I = 1:length(InputStrs)
  InputStrs{I} = [InputStrs{I},','];
end
InputStr1 = cell2mat(InputStrs);
InputStr1(end) = [];

Gfuncstr = ['function [Grd,Fun] = ',GrdFileName,'(',InputStr1,')\n'];
Hfuncstr = ['function [Hes,Grd,Fun] = ',HesFileName,'(',InputStr1,')\n'];

  % Print Function Header
for fid = [Gfid Hfid]
  fprintf(fid,['%% ',Gfuncstr,]);
  fprintf(fid,'%% \n');
  fprintf(fid,'%% Gradient wrapper file generated by ADiGator\n');
  fprintf(fid,['%% ',char(169),'2010-2014 Matthew J. Weinstein and Anil V. Rao\n']);
  fprintf(fid,['%% ',char(169),'2025 Pedro Lourenço @ GMV\n']);
  fprintf(fid,'%% This version of ADiGator may be obtained at https://github.com/pdlourenco/adigator-embedded \n');
  fprintf(fid,'%% Contact: mweinstein@ufl.edu\n');
  fprintf(fid,'%% Bugs/suggestions may be reported to the sourceforge forums\n');
  fprintf(fid,'%%                    DISCLAIMER\n');
  fprintf(fid,'%% ADiGator is a general-purpose software distributed under the GNU General\n');
  fprintf(fid,'%% Public License version 3.0. While the software is distributed with the\n');
  fprintf(fid,'%% hope that it will be useful, both the software and generated code are\n');
  fprintf(fid,'%% provided ''AS IS'' with NO WARRANTIES OF ANY KIND and no merchantability\n');
  fprintf(fid,'%% or fitness for any purpose or application.\n\n');
end

fprintf(Gfid,Gfuncstr);
fprintf(Hfid,Hfuncstr);
% Change the derivative input..

xfunstr = ['gator_',xstr,'.f'];
xderstr = ['gator_',xstr,'.d',vodname];
for fid = [Gfid Hfid]
  fprintf(fid,[xfunstr,' = ',xstr,';\n']);
  fprintf(fid,[xderstr,' = ones(%1.0f,1);\n'],prod(x.func.size));
end

InputStrs{derflag} = ['gator_',xstr,','];
InputStr2 = cell2mat(InputStrs);
InputStr2(end) = [];
ystr = FunctionInfo.Output.Names{1};

% Call the ADiGatorGrd/Hes files
fprintf(Gfid,[ystr,' = ',AdiGrdFileName,'(',InputStr2,');\n']);
fprintf(Hfid,[ystr,' = ',AdiHesFileName,'(',InputStr2,');\n']);

ysize = adiout.func.size;

% v1.5
% following the conventions on https://en.wikipedia.org/wiki/Matrix_calculus

%%% SCALAR FUNCTION OF VECTOR VARIABLE (GRADIENT)
% f: Rn -> R
% x in Rn
%
% Gradient_x(f) = [df/dx1
%                  ...
%                  df/dxn]
%
% size(Gradient_x(f)) = [length(x) length(f)]
%
% usage in computations: Gradient_x(f)' * x
%%% VECTOR FUNCTION OF VECTOR VARIABLE (JACOBIAN)
% f: Rn -> Rm
% x in Rn
%
% Jacobian(f)_x = [df1/dx1  ... df1/dxn
%                  ...
%                  dfm/dx1   ... dfn/dxn]
%
% size(Gradient(f)) = [length(x) length(f)]
%
% usage in computations: Jacobian_x(f) * x
%%% SCALAR FUNCTION OF VECTOR VARIABLE (HESSIAN)
% f: Rn -> Rm
% x in Rn
%
% Hessian(f)_x = [d2f/dx1dx1  ... d2f/dx1dxn
%                 ...
%                 d2f/dxndx1  ... d2f/dxndxn]
%
% size(Gradient(f)) = [length(x) length(f)]
%
% usage in computations: x' * Hessian_x(f) * x

%%% GENERALIZATION
% f: Rnxm -> Rrxc
% x in Rnxm
%
%		    c=1	    c=1	    c>1	    c>1
%		    r=1	    r>1	    r=1	    r>1
% n=1	m=1	1 x 1	r x 1	c x 1	r x c
% n=1	m>1	m x 1	r x m	c x m	r*c x m
% n>1	m=1	n x 1	r x n	c x n	r*c x n
% n>1	m>1	n x m	r x n*m	c x n*m	r*c x n*m

% Check to see how many non-zeros in Hessian
dydxdxnnz = size(adiout2.(['d',vodname]).deriv.nzlocs,1);
n = prod(xsize);
m = prod(ysize);
dydxdx = [ystr,'.d',vodname,'d',vodname];
if n == 1
  % derivative wrt a scalar..
  if m == 1 % function is a scalar
    fprintf(Hfid,['Hes = ',dydxdx,';\n']);
  elseif any(n == 1) % v1.5 - this is always true, as n is a scalar and equal to 1 ERROR
    fprintf(Hfid,'Hes = zeros(%1.0f,%1.0f);\n',ysize);
    fprintf(Hfid,['Hes(',dydxdx,'_location) = ',dydxdx,';\n']);
  elseif m>= 250 && dydxdxnnz/m <= 3/4 && opts.embed_mode == 'c' % v1.5 - only allow sparse matrices if in classic mode (no embed)
    % Sparse projection..
    rowind = [dydxdx,'_location(:,1)'];
    colind = [dydxdx,'_location(:,2)'];
    fprintf(Hfid,['Hes = sparse(',rowind,',',colind,',',dydxdx,',%1.0f,%1.0f);\n'],ysize);
  else
    rowind = [dydxdx,'_location(:,1)'];
    colind = [dydxdx,'_location(:,2)'];
    fprintf(Hfid,'Hes = zeros(%1.0f,%1.0f);\n',ysize);
    ind = sprintf(['(',colind,'-1)*%1.0f + ',rowind],ysize(1));
    fprintf(Hfid,['Hes(',ind,') = ',dydxdx,';\n']);
  end
else
  if m == 1
    % y scalar
    count = 0;
  % elseif any(ysize) == 1 % v1.5 probably an error, as ysize is always positive
  elseif any(ysize == 1)
    yind = 'yind';
    fprintf(Hfid,[yind,' = ',dydxdx,'_location(:,1);\n']);
    count = 1;
  else
    rowind = [dydxdx,'_location(:,1)'];
    colind = [dydxdx,'_location(:,2)'];
    yind = 'yind';
    fprintf(Hfid,[yind,' = (',colind,'-1)*%1.0f + ',rowind,';\n'],ysize(1));
    count = 2;
  end
  % if any(xsize) == 1 % v1.5 probably an error, as xsize is always positive
  if any(xsize == 1)
    count = count+1;
    xind1 = 'xind1';
    fprintf(Hfid,[xind1,' = ',dydxdx,'_location(:,%1.0f);\n'],count);
    count = count+1;
    xind2 = 'xind2';
    fprintf(Hfid,[xind2,' = ',dydxdx,'_location(:,%1.0f);\n'],count);
  else
    count  = count+1;
    rowind = sprintf([dydxdx,'_location(:,%1.0f)'],count);
    count  = count+1;
    colind = sprintf([dydxdx,'_location(:,%1.0f)'],count);
    xind1  = 'xind1';
    fprintf(Hfid,[xind1,' = (',colind,'-1)*%1.0f + ',rowind,';\n'],xsize(1));
    count  = count+1;
    rowind = sprintf([dydxdx,'_location(:,%1.0f)'],count);
    count  = count+1;
    colind = sprintf([dydxdx,'_location(:,%1.0f)'],count);
    xind2  = 'xind2';
    fprintf(Hfid,[xind2,' = (',colind,'-1)*%1.0f + ',rowind,';\n'],xsize(1));
  end
  if m == 1
    rowind = xind1;
  else
    rowind = 'xyind1';
    fprintf(Hfid,[rowind,' = (',xind1,'-1)*%1.0f + ',yind,';\n'],n);
  end
  if m*n*n >= 250 && dydxdxnnz/(m*n*n) <= 3/4 && opts.embed_mode == 'c' % v1.5 - only allow sparse matrices if in classic mode (no embed)
    fprintf(Hfid,['Hes = sparse(',rowind,',',xind2,',',dydxdx,',%1.0f,%1.0f);\n'],m*n,n);
  else
    fprintf(Hfid,'Hes = zeros(%1.0f,%1.0f);\n',m*n,n);
    ind = sprintf(['(',xind2,'-1)*%1.0f + ',rowind],m*n);
    fprintf(Hfid,['Hes(',ind,') = ',dydxdx,';\n']);
  end
end

% If dydx has => 250 elements and has <= 75% nonzeros, project into sparse
% matrix, otherwise project into full matrix.
dydxsize = [prod(ysize), prod(xsize)];
dydxnumel  = dydxsize(1)*dydxsize(2);
if dydxsize(1) == 1 && all(xsize>1) % scalar function of matrix variable
  dydxsize = xsize;
  ysize = [xsize(1) 1];
  xsize = [xsize(2) 1];
elseif dydxsize(2) == 1 && all(ysize>1) % matrix function of scalar variable
  dydxsize = ysize;
  xsize = [ysize(2) 1];
  ysize = [ysize(1) 1];
end
dydxnnz  = size(adiout.deriv.nzlocs,1);
% If dydx has => 250 elements and has <= 75% nonzeros, project into sparse
% matrix, otherwise project into full matrix.
dydx = [ystr,'.d',vodname];
%v1.5:	process this to output Jacobians correctly, i.e., in [m n] form ( m = numel(y), n = numel(x))
for fid = [Gfid,Hfid]
  if dydxnnz == dydxnumel % all elements are nonzero
    if dydxsize(1) == 1 % the function is a scalar, use the Gradient convention if user selected
        if strcmp(NameAppendix,'Jac') % Use Jacobian convention
            fprintf(fid,['Grd = reshape(',dydx,',[%1.0f %1.0f]);\n'],[dydxsize(1) dydxsize(2)]);
        else
            fprintf(fid,['Grd = reshape(',dydx,',[%1.0f %1.0f]);\n'],[dydxsize(2) dydxsize(1)]);
        end
    else % the function is not a scalar -> use the Jacobian convention
        fprintf(fid,['Grd = reshape(',dydx,',[%1.0f %1.0f]);\n'],dydxsize);
    end
  elseif dydxsize(1) == 1 && dydxsize(2) == 1 % function and variable are scalars
    fprintf(fid,['Grd = ',dydx,';\n']);
  elseif dydxsize(1) == 1 % function is scalar -> use Gradient convention if user selected Gradient
    if strcmp(NameAppendix,'Jac') % Use Jacobian convention
        fprintf(fid,'Grd = zeros(1,%1.0f);',dydxsize(2));
    else
        fprintf(fid,'Grd = zeros(%1.0f,1);',dydxsize(2));
    end
    fprintf(fid,['Grd(',dydx,'_location) = ',dydx,';\n']);
  elseif dydxsize(2) == 1 % variable is scalar -> use Jacobian convention
    fprintf(fid,'Grd = zeros(%1.0f,1);',dydxsize(1));
    fprintf(fid,['Grd(',dydx,'_location) = ',dydx,';\n']);
  else % Jacobian is a matrix -> Jacobian convention
    dyloc = [dydx,'_location'];
    if ~any(ysize == 1)
      % Output is matrix
      fprintf(fid,['funloc = (',dyloc,'(:,2)-1)*%1.0f + ',dyloc,'(:,1);\n'],ysize(1));
      rowstr = 'funloc';
      if ~any(xsize == 1)
        % Input is matrix
        fprintf(fid,['varloc = (',dyloc,'(:,4)-1)*%1.0f + ',dyloc,'(:,3);\n'],xsize(1));
        colstr = 'varloc';
      else
        colstr = [dyloc,'(:,3)'];
      end
    else
      rowstr = [dyloc,'(:,1)'];
      if ~any(xsize == 1)
        % Input is matrix
        fprintf(fid,['varloc = (',dyloc,'(:,3)-1)*%1.0f + ',dyloc,'(:,2);\n'],xsize(1));
        colstr = 'varloc';
      else
        colstr = [dyloc,'(:,2)'];
      end
    end
    if dydxnumel >= 250 && dydxnnz/dydxnumel <= 3/4 && opts.embed_mode == 'c' % v1.5 - only allow sparse matrices if in classic mode (no embed)
      % Project Sparse
      fprintf(fid,['Grd = sparse(',rowstr,',',colstr,',',dydx,',%1.0f,%1.0f)'';\n'],dydxsize);
    else
      % Project Full
      fprintf(fid,'Grd = zeros(%1.0f,%1.0f);\n',dydxsize);
      fprintf(fid,['Grd((',colstr,'-1)*%1.0f+',rowstr,') = ',dydx,';\n'],dydxsize(1));
    end
  end
  fprintf(fid,['Fun = ',ystr,'.f;\n']);
  fprintf(fid,'end');
end
fclose(fid);
rehash
%% --------------------- OUTPUT PROCESSING ------------------------------%%
output.FunctionFile = UserFunName;
% first derivative - Gradient (v1.5)
output.GenFiles(1) = ADi_DerivFiles;
output.GenFiles(1).main = ADiGator_GeneratedFiles.Grd;
output.GenFiles(1).name = GrdFileName;
output.GenFiles(1).func = ADi_DerivFuns;
% second derivative - Hessian (v1.5)
output.GenFiles(2) = updatestruct(output.GenFiles(1),ADi_DerivFiles2);
output.GenFiles(2).main = ADiGator_GeneratedFiles.Hes;
output.GenFiles(2).name = HesFileName;
output.GenFiles(2).func = ADi_DerivFuns2;
% remainder info
output.FunctionFile = UserFunName;
output.GradientFile = GrdFileName;
output.HessianFile  = HesFileName;
dydxdxlocs = adiout2.(['d',vodname]).deriv.nzlocs;
dydxlocs   = adiout.deriv.nzlocs;
HesLocs1 = dydxlocs(dydxdxlocs(:,1),:);
if n == 1
  HesPat = zeros(ysize);
  HesPat(HesLocs1(:,1)) = 1;
  output.HessianStructure = sparse(HesPat);
else
  HesRow   = (HesLocs1(:,2)-1)*m+HesLocs1(:,1);
  HesCol   = dydxdxlocs(:,2);
  output.HessianStructure = sparse(HesRow,HesCol,ones(dydxdxnnz,1),m*n,n);
end

fprintf(['\n<strong>adigatorGenHesFile</strong> successfully generated Hessian wrapper file: ''',HesFileName,''';\n\n']);

end
