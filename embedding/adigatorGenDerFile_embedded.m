function info = adigatorGenDerFile_embedded(DerType,UserFunName,UserFunInputs,varargin)
%ADIGATORGENDERFILE_EMBEDDED    This function generates embeddable files with
%                               implementing the selected derivatives of 
%                               the user provided UserFunName
%
% ADiGator Derivative File Generation Function: this function is used when you
% wish to generate a Hessian, gradient, or Jacobian of a function with an input variable
% of differentiation (and any auxiliary inputs), and a single output. This
% simply calls the function adigator twice and creates a wrapper function
% s.t. the input of the resulting file is the same as the input to the
% original user function, but outputs the Hessian, gradient, Jacobian, and 
% function values as requested.
%
% "Vanilla" ADiGator files use global variables and load .mat files in runtime
% which is not acceptable in embedded code. This file patches the vanilla
% files in one of two ways:
%       'c'lassic:      no patching is performed. 3 files are generated by
%                       each derivative (the main wrapper file, the .mat file
%                       containing the static indexing information, and the
%                       actual derivative file implementing ADiGator's 
%                       process.
%       coder'l'oad:    global variables are replaced by persistent variables
%                       the runtime load is replaced by a compile-time load
%                       and the values are set as constants. 2 files are
%                       generated: 1 m-file and 1 mat-file.
%       'i'nline:       no global or persistent variables are used, as well
%                       as loading. All the required information is within
%                       the generated Jacobian, Hessian, gradient file.
%
%   Input:
%       DerType         'jacobian', 'hessian', 'gradient' indicates the 
%                       chosen derivative
%       UserFunName     name of the user function to be differentiated
%       UserFunInputs   cell with list of inputs to the function
%                       can include differentiating variables or auxiliary
%                       use the adigatorCreateDerivInput(size,varname) and
%                               adigatorCreateAuxInput(size) utilities
%       options         optional input with the possible ADiGator options
%                       please consult adigatorOptions
%
%   Output:
%       info            information about the differentiation process
%
%	Dependencies:
%		adigatorGenJacFile, adigatorGenHesFile, structure_to_embed_mfile, adigator_patch_derivative
%
%   Copyright GMV, S.A.
%   Property of GMV, S.A.; all rights reserved
%   2025-10  PEDRO LOURENÃ‡O (PADL) - palourenco@gmv.com
%
%   Changelog:
%
%   TODO:
%       - Remove the computation of unnecessary variables by running CHECKCODE on each file.
%         Some functions load the mat file and assign Gator*Data structures but don't use them.
%         Each ADiGator derivative function returns the desired derivative as well as all 
%         lower order derivatives and the function itself. This might not be desirable in
%         embedded code, where only the minimum number of computations should take place

%% -------------------------- ARGUMENTS PARSING -------------------------%%
% parse options
opts = adigatorOptions();
if nargin>3
    optfields = fieldnames(varargin{1});
    for Fcount = 1:length(optfields)
        opts.(lower(optfields{Fcount})) = varargin{1}.(lower(optfields{Fcount}));
    end
else
    varargin = {opts};
end

%% --------------------- Call the ADiGator wrappers ---------------------%%
switch DerType
    case 'jacobian'
        info = adigatorGenJacFile(UserFunName,UserFunInputs,varargin{:});
    case 'hessian'
        info = adigatorGenHesFile(UserFunName,UserFunInputs,varargin{:});
    case 'gradient'
        info = adigatorGenJacFile(UserFunName,UserFunInputs,varargin{:},'Grd');
    otherwise
        error('Unsupported derivative type: %s', DerType);
end

switch opts.embed_mode
    case 'c' % classical mode, no embedding
        fprintf('User selected classical mode, no processing needed, exiting.\n');
        return;
    case 'i' % inline mode
        inline = true; coderload = false;
        fprintf('User selected inline mode (static data embedded in a function).\n');
    case 'l' % coderload
        coderload = true; inline = false;
        fprintf('User selected coderload mode.\n')
    otherwise
        error('unkown embed_mode option %s',opts.embed_mode);
end

%% ------------ Post-process according to user instructions -------------%%
% this is a structure array that includes all the files associated with all
% the derivatives in the form:
% .main - wrapper for calling adigator processing functions - path
% .m    - adigator generated processing of derivative (to be processed for embedding in main) - path
% .mat  - adigator generated static data (to be processed if user options = 'inline') - path
% .name - name of the main file
% .dername - name of the adigator generated processing
% .func - cell with the list of functions inside the .m file
%
% each element of the array is a single derivative (all files are standalone)
AdigatorGeneratedFiles = info.GenFiles;
N_derivs = length(AdigatorGeneratedFiles);

% go through each derivative
for derf = 1:N_derivs
    fprintf('Processing derivative #%d...\n',derf);

    %%% process the data file to prune it of unnecessary data for derivative evaluation
    fprintf('\t Processing static data file (cleaning up unnecessary data)... ');
    tmp_adigator_struct = load(AdigatorGeneratedFiles(derf).mat); % load data
    tmp_adigator_struct = prune_adigator_mat(tmp_adigator_struct,AdigatorGeneratedFiles(derf).func); % remove unnecessary fields
    save(AdigatorGeneratedFiles(derf).mat,'-struct','tmp_adigator_struct'); % replace existing mat file with the relevant fields only
    fprintf('done.\n');

    %%% if user requests inline option, the data is loaded from a function
    if inline
        % generate new data function (tmp)
        fprintf('\t\t Generating data function(s) as requested in inline mode...');
        for funidx=1:numel(AdigatorGeneratedFiles(derf).func)
            AdigatorGeneratedFiles(derf).data{funidx} = ['data_',AdigatorGeneratedFiles(derf).name,'_',AdigatorGeneratedFiles(derf).func{funidx}];
            AdigatorGeneratedFiles(derf).datapath{funidx} = structure_to_embed_mfile(AdigatorGeneratedFiles(derf).data{funidx},...
                                                            tmp_adigator_struct.(AdigatorGeneratedFiles(derf).func{funidx}),AdigatorGeneratedFiles(derf).path);
        end
        fprintf('done.\n');

        % patch the adigator generated derivative file
        fprintf('\t Processing ADiGator derivative file... ');
        auxiliary_deriv_filecontents = adigator_patch_derivative(AdigatorGeneratedFiles(derf).m,AdigatorGeneratedFiles(derf).dername,AdigatorGeneratedFiles(derf).func,0,AdigatorGeneratedFiles(derf).data);
        fprintf('done.\n');

        % cleanup (derivative file)
        delete(AdigatorGeneratedFiles(derf).m);
        % cleanup (static data file)
        delete(AdigatorGeneratedFiles(derf).mat);
    end

    %%% if user requests the coderload option, the data is loaded at compile time from a file
    if coderload
        % patch the adigator generated derivative file
        fprintf('\t Processing ADiGator derivative file... ');
        auxiliary_deriv_filecontents = adigator_patch_derivative(AdigatorGeneratedFiles(derf).m,AdigatorGeneratedFiles(derf).dername,AdigatorGeneratedFiles(derf).func,0);
        fprintf('done.\n');

        % cleanup (remove derivative file)
        delete(AdigatorGeneratedFiles(derf).m);
    end

    %%% embed derivative and data function into the main wrapper
    fprintf('\t Embed data and derivative functions... ');
    % patch main wrapper with %#codegen
    main_deriv_filecontents = adigator_patch_derivative(AdigatorGeneratedFiles(derf).main,AdigatorGeneratedFiles(derf).name,{AdigatorGeneratedFiles(derf).name},1);
    % write to file
    writelines(main_deriv_filecontents,AdigatorGeneratedFiles(derf).main,'WriteMode','overwrite');
    writelines(["";""],AdigatorGeneratedFiles(derf).main,'WriteMode','append');
    writelines(auxiliary_deriv_filecontents,AdigatorGeneratedFiles(derf).main,'WriteMode','append');
    if inline
        for dataf = 1:length(AdigatorGeneratedFiles(derf).data)
            tmp_data = readlines(AdigatorGeneratedFiles(derf).datapath{dataf});
            writelines(tmp_data,AdigatorGeneratedFiles(derf).main,'WriteMode','append');
            delete(AdigatorGeneratedFiles(derf).datapath{dataf});
        end
    end
    
    fprintf('done.\n')
end

end

%% ---------------- PRUNE ADIGATOR_DERIVATIVE DATA ------------------%%
function structout = prune_adigator_mat(structin,funnames)
% PRUNE_ADIGATOR_MAT
% Keep only <funcName>.Gator*Data.Index* per derivative function.
% Downcast integer-valued arrays to int32/uint32 to shrink embedded consts.

for jj = 1:numel(funnames) % go through each of the functions
    if isfield(structin,funnames{jj}) % if field exists, save it
        fn = fieldnames(structin.(funnames{jj}));
        keepTop = fn(startsWith(fn, "Gator") & endsWith(fn,"Data"));
        auxstruct = struct();

        for ii = 1:numel(keepTop)
            gname = keepTop{ii};
            G = structin.(funnames{jj}).(gname);
            if ~isstruct(G), continue; end
            fG = fieldnames(G);

            % Keep only Index* subfields
            keepIdx = fG(startsWith(fG, "Index"));
            if isempty(keepIdx), continue; end

            G2 = struct();
            for k = 1:numel(keepIdx)
                idxName = keepIdx{k};
                A = G.(idxName);

                % Down-cast numeric integer arrays to save memory
                if isnumeric(A) && isreal(A) && all(isfinite(A(:))) && all(abs(A(:) - round(A(:))) < 1e-12)
                    % Nonnegative? prefer uint32; otherwise int32
                    if all(A(:) >= 0)
                        A = uint32(A);
                    else
                        A = int32(A);
                    end
                end
                % Logical stays logical; other types left as-is (doubles etc.)
                G2.(idxName) = A;
            end

            if ~isempty(fieldnames(G2))
                auxstruct.(gname) = G2;
            end
        end
        structout.(funnames{jj}) = auxstruct;
    end
end
end