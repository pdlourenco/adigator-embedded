function filepath = structure_to_embed_mfile(funcName, dataStruct, outPath)
%structure_to_embed_mfile Write a MATLAB helper function that returns DATASTRUCT as literals.
%   emit_data_helper_file(FUNCNAME, DATASTRUCT, OUTPATH)
%     - FUNCNAME  : name of the function to generate (string/char)
%     - DATASTRUCT: struct (e.g., with fields Gator1Data, ...)
%     - OUTPATH   : folder to write FUNCNAME.m into (string/char)
%
% The generated function has signature:
%     function S = <FUNCNAME>() %#codegen
% and returns a struct S populated with fixed-size literal arrays/cells/structs.
%
% Supported leaf types: double/single/logical (real/complex), struct, cell, char.
% (If strings appear, they are converted to char.) Sparse arrays are not supported.
%
%	Dependencies:
%		none
%
%   Copyright 2025 Pedro Louren√ßo
%
%   Changelog:
%   

arguments
  funcName   (1,1) string
  dataStruct (1,1) struct
  outPath    (1,1) string = pwd
end

filepath = fullfile(outPath, funcName + ".m");
[fid,msg] = fopen(filepath, 'w');
if fid < 0, error("structure_to_embed_mfile:io", "Cannot open file: %s (%s)", filepath, msg); end

cleanupObj = onCleanup(@() fclose(fid));

% File header
fprintf(fid, 'function S = %s()\n%%#codegen\n', funcName);
ts = string(datetime('now','Format','yyyy-MM-dd HH:mm:ss'));
fprintf(fid, '%% Auto-generated by structure_to_embed_mfile on %s\n% Helper file for ADiGator generated derivatives', ts);
fprintf(fid, 'S = struct();\n');

% Emit each top-level field of the input struct into S.<field>
fns = fieldnames(dataStruct);
for k = 1:numel(fns)
    fld = fns{k};
    emit_value(fid, "S." + fld, dataStruct.(fld), 0);
end

fprintf(fid, 'end\n');
end

% ===================== Helpers =====================

function emit_value(fid, lhs, val, indent)
% Recursively print "lhs = <literal>;" (or series of assignments) for val.

pad = repmat(' ', 1, 2*indent);

if isstring(val), val = char(val); end

if isstruct(val)
    fprintf(fid, '%s%s = struct();\n', pad, lhs);
    flds = fieldnames(val);
    for i = 1:numel(flds)
        emit_value(fid, lhs + "." + flds{i}, val.(flds{i}), indent);
    end
    return
end

if iscell(val)
    sz = size(val);
    % Create cell of the same size
    fprintf(fid, '%s%s = cell(%s);\n', pad, lhs, size_vec(sz));
    % Assign each element
    for idx = 1:numel(val)
        subs = idx_to_sub(sz, idx);
        emit_value(fid, sprintf('%s{%s}', lhs, subs), val{idx}, indent);
    end
    return
end

if isnumeric(val) || islogical(val)
    emit_numeric(fid, lhs, val, indent);
    return
end

if ischar(val)
    fprintf(fid, '%s%s = ''%s'';\n', pad, lhs, escape_char(val));
    return
end

error('emit_data_helper_file:unsupported', ...
      'Unsupported type at %s: %s', lhs, class(val));
end

function emit_numeric(fid, lhs, A, indent)
% Emit numeric/logical (real or complex), any ndim, fixed-size.
pad = repmat(' ', 1, 2*indent);
sz = size(A);

% Empty
if isempty(A)
    if islogical(A)
        fprintf(fid, '%s%s = false(%s);\n', pad, lhs, size_vec(sz));
    else
        fprintf(fid, '%s%s = zeros(%s);\n', pad, lhs, size_vec(sz));
    end
    return
end

% Scalars can be direct
if isscalar(A)
    if isreal(A)
        fmt = pick_fmt(A);
        fprintf(fid, ['%s%s = ' fmt ';\n'], pad, lhs, A);
    else
        fprintf(fid, '%s%s = %s;\n', pad, lhs, complex_literal(A));
    end
    return
end

% General case: use column-major reshape of a flat literal vector
n = numel(A);

% Start building the vector literal in chunks to keep lines short
fprintf(fid, '%s%s = reshape([', pad, lhs);

chunk = 16; % numbers per line
for i = 1:n
    if isreal(A)
        fprintf(fid, '%s ', num2str(A(i), pick_fmt(A)));
    else
        fprintf(fid, '%s ', complex_literal(A(i)));
    end
    if mod(i, chunk) == 0 && i ~= n
        fprintf(fid, '...\n%s              ', pad); % aligned continuation
    end
end
fprintf(fid, '], %s);\n', size_vec(sz));
end

function s = complex_literal(z)
% Return a MATLAB literal for a (possibly complex) scalar z
r = real(z); i = imag(z);
s = sprintf('(%s) + 1i*(%s)', num2str(r, '%.17g'), num2str(i, '%.17g'));
end

function fmt = pick_fmt(A)
% Choose numeric format; default to full precision for doubles/singles
if isa(A, 'single')
    fmt = '%.9g';
else
    fmt = '%.17g';
end
end

function s = size_vec(sz)
% Turn a size vector into 'd1,d2,...,dk'
s = strjoin(string(sz), ', ');
end

function subs = idx_to_sub(sz, idx)
% Linear index -> comma-separated subscripts for any ndim
v = cell(1, numel(sz));
[v{:}] = ind2sub(sz, idx);
subs = strjoin(string([v{:}]), ', ');
end

function t = escape_char(c)
% Escape single quotes for MATLAB char literals
t = strrep(c, '''', '''''');
end
